USE chirp
-- Sadly, TSQL scripts don't seem to crash
-- IF chirp doesn't exist, this script continues after the GO statement.


GO

IF NOT EXISTS ( SELECT * FROM sys.schemas WHERE name='private')
	EXEC('CREATE SCHEMA private')
GO
IF OBJECT_ID('[private].identifiers', 'U') IS NOT NULL
	DROP TABLE [private].identifiers;
CREATE TABLE [private].identifiers (
	id int IDENTITY(1,1) PRIMARY KEY,
	chirp_id      INT NOT NULL,
	source_schema VARCHAR(50) NOT NULL,
	source_table  VARCHAR(50) NOT NULL,
	source_column VARCHAR(50) NOT NULL,
	source_id     VARCHAR(255) NOT NULL,
	created_at    DATETIME 
		CONSTRAINT private_identifiers_created_at_default 
		DEFAULT CURRENT_TIMESTAMP NOT NULL,
	CONSTRAINT unique_source_identifiers
		UNIQUE (source_schema,source_table,source_column,source_id)
);
GO
--4*255=1020. Its unlikely that any of these will be 255 chars. Shrinking.
--Warning! The maximum key length is 900 bytes. The index 'unique_source_identifiers' has maximum length of 1020 bytes. For some combination of large values, the insert/update operation will fail.


--Can't use RAND() in function. This is a workaround.
--http://blog.sqlauthority.com/2012/11/20/sql-server-using-rand-in-user-defined-functions-udf/
GO
CREATE VIEW rndView
AS
SELECT RAND() rndResult
GO

IF OBJECT_ID ( 'create_unique_chirp_id', 'FN' ) IS NOT NULL
	DROP PROCEDURE create_unique_chirp_id;
GO
CREATE FUNCTION create_unique_chirp_id()
RETURNS INT
BEGIN
	DECLARE @MINID INT = 1e9;
	DECLARE @MAXID INT = POWER(2.,31)-1;
	DECLARE @TEMPID INT = 0;
	DECLARE @rndValue DECIMAL(18,18)

	WHILE ((@TEMPID = 0) OR
		EXISTS (SELECT * FROM [private].identifiers WHERE chirp_id=@TEMPID))
	BEGIN
		SELECT @rndValue = rndResult FROM rndView
		-- By using a min of 1e9, no need for leading zeroes.
		SET @TEMPID = CAST(
			(@MINID + (@rndValue * (@MAXID-@MINID)))
			AS INTEGER);
	END

	RETURN @TEMPID
END
GO





--This works
--
--INSERT INTO [private].[identifiers] 
--	( chirp_id, source_schema, source_table, source_column, source_id ) 
--	SELECT dbo.create_unique_chirp_id(), 'vital_records', 'birth', 'state_file_number', 
--			state_file_number from vital_records.birth;


